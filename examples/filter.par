type Func<a, b> = iterative choice {
  .drop => !
  .apply(a) => (b) self
}

dec Filter : [Func<Nat, Bool>, List<Nat>] List<Nat>
def Filter = [predicate, list] list.begin.case {
  .end! => do {
    predicate.drop?
  } in .end!

  .item(value) rest => do {
    predicate.apply(value)[result]
  } in result.case {
    .true! => .item(value) rest.loop
    .false! => rest.loop
  }
}

dec Not : [Bool] Bool
def Not = [b] b.case { .true! => .false!, .false! => .true! }

dec IsEven : Func<Nat, Bool>
def IsEven = begin case {
  .drop => !
  .apply(n) => (Nat.Equals(0, Nat.Mod(n, 2))) loop
}

def FilterEven = Filter(IsEven)
