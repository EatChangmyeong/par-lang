type Bool    = either { .true!, .false! }
type Nat     = recursive either { .zero!, .add1 self }
type List<a> = recursive either { .empty!, .item(a) self }

type Func<a, b> = iterative choice {
  .drop => !
  .apply(a) => (b) self
}

dec Filter : [Func<Nat, Bool>, List<Nat>] List<Nat>
def Filter = [predicate, list] list.begin.case {
  .empty! => do {
    predicate.drop?
  } in .empty!

  .item(value) rest => do {
    predicate.apply(value)[result]
  } in result.case {
    .true! => .item(value) rest.loop
    .false! => rest.loop
  }
}

dec Not : [Bool] Bool
def Not = [b] b.case { .true! => .false!, .false! => .true! }

dec IsEven : Func<Nat, Bool>
def IsEven = begin case {
  .drop => !
  .apply(n) => (n.begin.case {
    .zero!  => .true!
    .add1 n => Not(n.loop)
  }) loop
}

def FilterEven = Filter(IsEven)
