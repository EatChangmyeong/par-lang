type Bool  = either { .true!, .false! }
type Option<a>  = either { .some a, .none! }

dec True : Bool
def True = .true!
dec False : Bool
def False = .false!

dec Not : [Bool] Bool
def Not = [x] x.case {
	.true! => .false!,
	.false! => .true!
}


type Tree = recursive either {
  .empty!
  .item(self)(self)!
}

dec Empty : Tree
def Empty = .empty!

dec Tree : Tree
def Tree =
    let b: Tree = .item(Empty)(Empty)! in
    .item(Empty)(b)!


dec Xor : [Bool][Bool] Bool
def Xor = [a][b] a.case {
	.true! => Not(b),
	.false! => b
}

dec XorTree: [Tree] Bool

def XorTree = [tree: Tree] tree.begin.case {
	.empty! => .true!,
	.item(lst1)(lst2)! => Xor(lst1.loop)(lst2.loop)
}


dec IsSome : [Option<Bool>] Bool
def IsSome = [option: Option<Bool>] option.case {
    .some val => val,
    .none! => .false!
}

dec Main : Tree
def Main = .empty!

dec Quant : (type a) (a) (a) [a] [a] Bool
def Quant = (type Bool) (.true!) (.false!) [x] [y] x.case {
    .true! => y.case {
        .true! => .false!,
        .false! => .true!
    }
    .false! => y.case {
        .true! => .false!,
        .false! => .true!
    }

}

type Color = either { .red!, .green!, .blue! }

type List<a> = recursive either {
  .empty!
  .item(a) self
}

type Seq<a> = iterative choice {
  .close => !
  .next  => (a) self
}

type Mapper<a, b> = iterative choice {
  .close    => !
  .apply(a) => (b) self
}

dec MapList : [type a, b] [List<a>, Mapper<a, b>] List<b>
def MapList = [type a, b] [list, mapper]
  list.begin.case {
    .empty! => do {
      mapper.close?
    } in .empty!

    .item(x) xs => do {
      mapper.apply(x)[y]
    } in .item(y) xs.loop
  }

dec MapSeq : [type a, b] [Seq<a>, Mapper<a, b>] Seq<b>
def MapSeq = [type a, b] [seq, mapper]
  begin case {
    .close => do {
      seq.close?
      mapper.close?
    } in !
    .next => do {
      seq.next[x]
      mapper.apply(x)[y]
    } in (y) loop
  }

dec ListRGB : List<Color>
def ListRGB =
  .item(.red!)
  .item(.green!)
  .item(.blue!)
  .empty!

dec RedForever : Seq<Color>
def RedForever = begin case {
  .close => !
  .next  => (.red!) loop
}

dec RGB : [Color] Color
def RGB = [value] value.case {
  .red!   => .red!
  .green! => .green!
  .blue!  => .blue!
}

dec Swap : [Bool] Bool
def Swap = [bool] bool.case {
  .true! => .false!
  .false! => .true!
}

def BoolForever =
  let bool: Bool = .true! in
  begin case {
    .close => bool.case {
      .true! => !
      .false! => !
    }
    .next => {
      let (output: Bool, bool: Bool)! = bool.case {
        .true! => (.true!, .false!)!
        .false! => (.false!, .true!)!
      } in (output) loop
    }
  }

dec Zip : [type a, b] [List<a>, Seq<b>] List<(a, b)!>
def Zip = [type a, b] [list, seq] list.begin.case {
  .empty! => do {
    seq.close?
  } in .empty!

  .item(x) xs => do {
    seq.next[y]
  } in .item((x, y)!) xs.loop
}

def Zipped = Zip(type Color, Color)(ListRGB, RedForever)

def Zip2 = [type a, b] [seq1: Seq<a>, seq2: Seq<b>] begin case {
  .close => do {
    seq1.close?
    seq2.close?
  } in !

  .next => do {
    seq1.next[x]
    seq2.next[y]
  } in ((x, y)!) loop
}



type Alternate<a, b> = recursive either {
  .remainder either {
    .left List<a>,
    .right List<b>,
  },
  .choose choice {
    .left => (a) self,
    .right => (b) self,
  },
}

dec Alternate : [type a, b] [List<a>, List<b>] Alternate<a, b>

def Alternate = [type a, b] [la, lb] la.begin/a.case {
  .empty! => .remainder .right lb,
  .item(ha) la => lb.begin/b.case {
    .empty! => .remainder .left .item (ha) la,
    .item (hb) lb => .choose case {
      .left => (ha) let lb: List<b> = .item (hb) lb in la.loop/a
      .right => (hb) lb.loop/b
    }
  }
}


dec LeftList  : List<Bool>
dec RightList : List<Bool>

def LeftList  = .item(.true!).item(.true!).empty!
def RightList = .item(.true!).empty!

def AlternateApplied = Alternate(type Bool)(type Bool)(LeftList)(RightList)
