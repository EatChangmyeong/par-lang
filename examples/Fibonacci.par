type Sequence<a> = iterative choice {
  .close => !
  .next  => (a) self
}

dec Fibonacci : Sequence<Nat>
def Fibonacci =
  let (a) b = (0) 1
  in begin case {
    .close => !
    .next =>
      let (a) b = (b) Nat.Add(a, b)
      in (a) loop
  }

dec NthFib : [Nat] Nat
def NthFib = [n]
  let fib = Fibonacci
  in Nat.Repeat(n).begin.case {
    .end!   => do { fib.next[x].close? } in x,
    .step s => do { fib.next[_] } in s.loop,
  }

def Program: ! = do {
  let console = Console.Open
  let fib = Fibonacci

  Nat.Repeat(30).begin.case {
    .end! => {}
    .step remaining => {
      fib.next[n]
      console.print(Nat.ToString(n))
      remaining.loop
    }
  }

  fib.close
  console.close
} in !

def TestNthFib: [Test] ! = [test] do {
  test
    .assert("NthFib(0) should be 1", Nat.Equals(NthFib(0), 1))
    .assert("NthFib(1) should be 1", Nat.Equals(NthFib(1), 1))
    .assert("NthFib(2) should be 2", Nat.Equals(NthFib(2), 2))
    .assert("NthFib(3) should be 3", Nat.Equals(NthFib(3), 3))
    .assert("NthFib(4) should be 5", Nat.Equals(NthFib(4), 5))
    .assert("NthFib(5) should be 8", Nat.Equals(NthFib(5), 8))
    .assert("NthFib(6) should be 13", Nat.Equals(NthFib(6), 13))
    .assert("NthFib(10) should be 89", Nat.Equals(NthFib(10), 89))
} in !
