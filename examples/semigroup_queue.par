type Nat = recursive either {
  .zero !
  .succ self
}

dec Zero : Nat
def Zero = .zero!
dec One : Nat
def One = .succ .zero !
dec Two : Nat
def Two = .succ .succ .zero !

dec NatAdd: [Nat] [Nat] Nat
def NatAdd = [n] [m] n.begin.case {
  .zero! => m,
  .succ n => .succ n.loop
}

def Three = NatAdd(One)(Two)

dec NatEra: [Nat] !
def NatEra = [n] n.begin.case {
  .zero! => !
  .succ n => n.loop
}

dec NatDup: [Nat] (Nat) Nat
def NatDup = [n] n.begin.case {
  .zero! => (.zero!) .zero!
  .succ n => let (a)b = n.loop in
    (.succ a) .succ b
}

dec NatMul: [Nat] [Nat] Nat
def NatMul = [n] [m] n.begin.case {
  .zero! => let ! = NatEra(m) in Zero,
  .succ n => let (m2)m = NatDup(m) in
    NatAdd(m2)(n.loop)
}

type Stream<a> = iterative choice {
  .end => !
  .next => (a) self
}

dec Nats: Stream<Nat>
def Nats = let m = Zero in
  begin case {
    .end => NatEra(m),
    .next => {
      let (m2)m = NatDup(m) in
      let m: Nat = .succ m in
      (m2) loop
    }
  }

type Dup<a> = iterative choice {
  .end => !
  .new => (self) self
  .dup(a) => (a) (a) self
}
type Era<a> = iterative choice {
  .end => !
  .new => (self) self
  .era(a) => self
}

dec InstDupNat: Dup<Nat>
def InstDupNat = begin case {
  .end => !
  .new => (loop) loop
  .dup(n) => let (n2)n = NatDup(n) in (n2)(n) loop
}
dec InstEraNat: Era<Nat>
def InstEraNat = begin case {
  .end => !
  .new => (loop) loop
  .era(n) => let ! = NatEra(n) in loop
}

type Add<a> = iterative choice {
  .end => !
  .new => (self) self
  .add(a)(a) => (a) self
}

dec InstAddNat: Add<Nat>
def InstAddNat = begin case {
  .end => !
  .new => (loop) loop
  .add(n)(m) => (NatAdd(n)(m)) loop
}

type Mul<a> = iterative choice {
  .end => !
  .new => (self) self
  .mul(a)(a) => (a) self
}

dec InstMulNat: Mul<Nat>
def InstMulNat = begin case {
  .end => !
  .new => (loop) loop
  .mul(n)(m) => (NatMul(n)(m)) loop
}

type Option<a> = either {
  .none!
  .some a
}

dec IntEraOption : [type a] [Era<a>] Era<Option<a>>
def IntEraOption = [type a] [instEra] begin case {
  .end => do {instEra.end?} in !
  .new => do {instEra.new[instEra2]} in (loop) let instEra = instEra2 in loop
  .era(option) => option.case {
    .none! => loop
    .some t => do {instEra.era(t)} in loop
  }
}

type Stack<a> = recursive either {
  .empty!
  .item (a) self
}

dec StackNew : [type a] Stack<a>
def StackNew = [type a] .empty!

dec InstEraStack : [type a] [Era<a>] Era<Stack<a>>
def InstEraStack = [type a] [instEra] begin/out case {
  .end => do {instEra.end?} in !
  .new => do {instEra.new[inst]} in (loop/out) let instEra = inst in loop/out
  .era => [s] s.begin/inner.case {
    .empty! => loop/out
    .item(t) s => do {instEra.era(t)} in s.loop/inner
  }
}

dec StackPop : [type a] [Stack<a>] (Option<a>) Stack<a>
def StackPop = [type a] [s] s.case {
  .item(t) s => (.some t) s,
  .empty! => (.none!) .empty!
}

dec StackPush : [type a] [Stack<a>] [a] Stack<a>
def StackPush = [type a] [s] [t] .item (t) s

dec StackReverse : [type a] [Stack<a>] Stack<a>
def StackReverse = [type a] [s] let snew: Stack<a> = .empty! in s.begin.case {
  .empty! => snew,
  .item(t) s => let snew = StackPush(type a)(snew)(t) in s.loop
}

// def test_Stack_reverse = Stack_reverse(type Nat)(.item(one) .item(two) .item(three) .empty!)

type Queue<a> =
  (Stack<a>)
  Stack<a>

dec QueueNew : [type a] Queue<a>
def QueueNew = [type a] (StackNew(type a)) StackNew(type a)

dec InstEraQueue: [type a] [Era<a>] Era<Queue<a>>
def InstEraQueue = [type a] [instEra]
  let instEraStack = InstEraStack(type a)(instEra) in
  begin case {
    .end => do {instEraStack.end?} in !
    .new => do {instEraStack.new[inst]} in (loop) let instEraStack = inst in loop
    .era((l) r) => do {
      instEraStack.era(l).era(r)
    } in loop
  }

dec QueuePush : [type a] [Queue<a>] [a] Queue<a>
def QueuePush = [type a] [(l) r] [t]
  let l = StackPush(type a)(l)(t) in
  (l)r

dec QueuePop : [type a] [Queue<a>] (Option<a>) Queue<a>
def QueuePop = [type a] [(l) r] r.case {
  .item(t) r => (.some t) (l)r,
  .empty! => let r = StackReverse(type a)(l) in let l: Stack<a> = .empty! in r.case {
    .empty! => (.none!) (l) .empty!
    .item(t) r => (.some t) (l) r
  }
}

// def test_Queue_pop = Queue_pop(type Nat)((.item (one) .empty!) .item (three) .item (two) .empty!)

// A semigroup has an associative operation called `mul`.
// Par doesn't (currently?) have proofs so this is equivalent to `Mul`.
// See <https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Semigroup>
type Semigroup<a> = iterative choice {
  .end => !
  .new => (self) self
  .mul(a)(a) => (a) self // since instances are explicitly named conflict with Mul.mul with subtyping is fine (actually makes Mul the same as Semigroup)
}

// Stack which keeps track of cumulative semigroup value
// Order is (item) cumulative_measure
type SemigroupStack<a> = Stack<(a) a>

dec SemigroupStackNew : [type a] SemigroupStack<a>
def SemigroupStackNew = [type a] StackNew(type (a) a)

dec InstEraPair : [type a] [Era<a>] Era<(a) a>
def InstEraPair = [type a] [instEra] begin case {
    .end => do {instEra.end?} in !
    .new => do {instEra.new[inst]} in (loop) let instEra = inst in loop
    .era((t1: a) t2: a) => do {instEra.era(t1).era(t2)} in loop
  }

dec InstDupPair : [type a] [Dup<a>] Dup<(a) a>
def InstDupPair = [type a] [instDup] begin case {
    .end => do {instDup.end?} in !
    .new => do {instDup.new[inst]} in (loop) let instDup = inst in loop
    .dup((t1: a) t2: a) => do {instDup.dup(t1)[t1][t12].dup(t2)[t2][t22]}
      in ((t1) t2) ((t12) t22) loop
  }

dec InstEraSemigroupStack : [type a] [Era<a>] Era<SemigroupStack<a>>
def InstEraSemigroupStack = [type a] [instEra]
  let instEraPair = InstEraPair(type a)(instEra) in
  let instEraStack = InstEraStack(type (a) a)(instEraPair) in
  begin case {
    .end => do {instEraStack.end?} in !
    .new => do {instEraStack.new[inst]} in (loop) let instEraStack = inst in loop
    .era(t) => do {instEraStack.era(t)} in loop
  }

dec SemigroupStackPop : [type a] [SemigroupStack<a>] (Option<(a) a>) SemigroupStack<a>
def SemigroupStackPop = [type a] [s] StackPop(type (a) a)(s)

dec SemigroupStackPush : [type a] [Dup<a>] [Semigroup<a>] [SemigroupStack<a>] [a] SemigroupStack<a>
def SemigroupStackPush = [type a] [instDup] [instSemigroup] [s] [t]
  do {instDup.dup(t)[t][t2]} in
  let (p)s = SemigroupStackPop(type a)(s) in p.case { // Peek
    .none! => do {instSemigroup.end? instDup.end?} in StackPush(type (a) a)(s)((t) t2),
    .some(p) pm =>
      do {instDup.dup(pm)[pm][pm2]} in
      let s = StackPush(type (a) a)(s)((p) pm) in // return peeked element back into the stack
      do {instSemigroup.mul(pm2)(t2)[tm]} in
      do {instSemigroup.end? instDup.end?} in
      StackPush(type (a) a)(s)((t) tm)
  }

dec SemigroupStackPeek : [type a] [Era<a>] [Dup<a>] [Semigroup<a>] [SemigroupStack<a>] (Option<(a) a>) SemigroupStack<a>
def SemigroupStackPeek = [type a] [instEra] [instDup] [instSemigroup] [s]
  do {instDup.new[inst]} in
  let instDupPair = InstDupPair(type a)(inst) in
  let (t)s = SemigroupStackPop(type a)(s) in t.case {
  .none! => do {instEra.end? instSemigroup.end? instDupPair.end? instDup.end?}
    in (.none !) s,
  .some t =>
    do {instDupPair.dup(t)[t][t2]} in
    let s: SemigroupStack<a> = .item (t) s in
    do {instEra.end? instSemigroup.end? instDupPair.end? instDup.end?} in
    (.some t2) s
}


dec SemigroupStackReverse : [type a] [Era<a>] [Dup<a>] [Semigroup<a>] [SemigroupStack<a>] SemigroupStack<a>
def SemigroupStackReverse = [type a] [instEra] [instDup] [instSemigroup] [s] let snew: SemigroupStack<a> = SemigroupStackNew(type a) in s.begin.case {
  .empty! => do {instSemigroup.end? instDup.end? instEra.end?} in snew,
  .item((t) m) s => do {
    instEra.era(m)
    instDup.new[instDup2]
    instSemigroup.new[instSemigroup2]
    } in
    let snew = SemigroupStackPush(type a)(instDup2)(instSemigroup2)(snew)(t)
    in s.loop
}

// See <https://byorgey.github.io/blog/posts/2024/11/27/stacks-queues.html>
// This is slightly more general because `T` doesn't need an identity element.
type SemigroupQueue<a> = Queue<(a) a>

dec SemigroupQueueNew : [type a] SemigroupQueue<a>
def SemigroupQueueNew = [type a] QueueNew(type (a) a)

dec InstEraSemigroupQueue : [type a] [Era<a>] Era<SemigroupQueue<a>>
def InstEraSemigroupQueue = [type a] [instEra]
  let instEraPair = InstEraPair(type a)(instEra) in
  let instEraQueue = InstEraQueue(type (a) a)(instEraPair) in
  begin case {
    .end => do {instEraQueue.end?} in !
    .new => do {instEraQueue.new[inst]} in (loop) let instEraQueue = inst in loop
    .era(q) => do {instEraQueue.era(q)}  in loop
  }

dec SemigroupQueuePush : [type a] [Dup<a>] [Semigroup<a>] [SemigroupQueue<a>] [a] SemigroupQueue<a>
def SemigroupQueuePush = [type a] [instDup] [instSemigroup] [(l) r] [t]
  let l = SemigroupStackPush(type a)(instDup)(instSemigroup)(l)(t) in
  (l)r

dec SemigroupQueuePop : [type a] [Era<a>] [Dup<a>] [Semigroup<a>] [SemigroupQueue<a>] (Option<(a) a>) SemigroupQueue<a>
def SemigroupQueuePop = [type a] [instEra] [instDup] [instSemigroup] [(l) r]
  let (t)r = SemigroupStackPop(type a)(r) in t.case {
    .some t => do {instEra.end? instDup.end? instSemigroup.end?} in (.some t) (l)r,
    .none! => do {instEra.new[inst]} in
      let ! = InstEraSemigroupStack(type a)(inst).era(r).end in
      do {instEra.new[inst]} in
      let r = SemigroupStackReverse(type a)(inst)(instDup)(instSemigroup)(l) in
      let l = SemigroupStackNew(type a) in
      let (t)r = SemigroupStackPop(type a)(r) in t.case {
        .none! =>  let ! = InstEraSemigroupStack(type a)(instEra).era(r).end in
          (.none!) (l) .empty!
        .some t => do {instEra.end?} in (.some t) (l) r
  }
}

dec SemigroupQueuePeek: [type a] [Era<a>] [Dup<a>] [Semigroup<a>] [SemigroupQueue<a>] (Option<(a) a>) SemigroupQueue<a>
def SemigroupQueuePeek = [type a] [instEra] [instDup] [instSemigroup] [(l)r]
  do {
    instEra.new[instEra2].new[instEra3]
    instDup.new[instDup2].new[instDup3]
    instSemigroup.new[instSemigroup2].new[instSemigroup3]
  } in
  let (tl)l = SemigroupStackPeek(type a)(instEra2)(instDup2)(instSemigroup2)(l) in
  let (tr)r = SemigroupStackPeek(type a)(instEra3)(instDup3)(instSemigroup3)(r) in

  // Use larger of the two measures if both stacks have elements.
  // If only 1 stack make sure it is the right stack, and use that measure.
  tl.case {
    .none! => tr.case {
      .none! => do {
        instEra.end?
        instSemigroup.end?
        instDup.end?
      } in (.none!) (l) r,
      .some(tr)trm => do {
        instEra.end?
        instSemigroup.end?
        instDup.end?
      } in (.some (tr) trm) (l) r
    }
    .some (tl)tlm => tr.case {
      .none! => do {
          instEra.era(tl).era(tlm).new[instEra2].new[instEra3]
          instDup.new[instDup2]
          instSemigroup.new[instSemigroup2]
        } in
        let ! = InstEraSemigroupStack(type a)(instEra2).era(r).end in
        let r = SemigroupStackReverse(type a)(instEra3)(instDup2)(instSemigroup2)(l) in
        let l = SemigroupStackNew(type a) in
        // Repeat now that the left stack is empty and the right is not.
{
do {
    instEra.new[instEra2].new[instEra3]
    instDup.new[instDup2].new[instDup3]
    instSemigroup.new[instSemigroup2].new[instSemigroup3]
  } in
  let (tl)l = SemigroupStackPeek(type a)(instEra2)(instDup2)(instSemigroup2)(l) in
  let (tr)r = SemigroupStackPeek(type a)(instEra3)(instDup3)(instSemigroup3)(r) in

  // Use larger of the two measures if both stacks have elements.
  // If only 1 stack make sure it is the right stack, and use that measure.
  tl.case {
    .none! => tr.case {
      .none! => do {
        instEra.end?
        instSemigroup.end?
        instDup.end?
      } in (.none!) (l) r,
      .some(tr)trm => do {
        instEra.end?
        instSemigroup.end?
        instDup.end?
      } in (.some (tr) trm) (l) r
    }
    .some (tl)tlm => tr.case {
      //unreachable
      .none! => do {
          instEra.era(tl).era(tlm).end?
          instDup.end?
          instSemigroup.end?
        } in
        // Repeat now that the left stack is empty and the right is not.
        (.none!) (l) r,
      .some (tr)trm => do {
        instSemigroup.mul(tlm)(trm)[tm].end?
        instEra.era(tl).end?
        instDup.end?
      } in (.some (tr) tm) (l) r
    }
  }
},
      .some (tr)trm => do {
        instSemigroup.mul(tlm)(trm)[tm].end?
        instEra.era(tl).end?
        instDup.end?
      } in (.some (tr) tm) (l) r
    }
  }

dec NatMax : [Nat] [Nat] Nat
def NatMax = [n] [m] n.begin.case {
  .zero! => m,
  .succ n => m.case {
    .zero! => .succ n,
    .succ m => .succ n.loop
  }
}

dec NatMin: [Nat] [Nat] Nat
def NatMin = [n] [m] n.begin.case {
  .zero! => let ! = InstEraNat.era(m).end in .zero!
  .succ n => m.case {
    .zero! => let ! = InstEraNat.era(n).end in .zero!
    .succ m => .succ n.loop
  }
}

dec InstSemigroupNatMax: Semigroup<Nat>
def InstSemigroupNatMax = begin case {
  .end => !
  .new => (loop) loop
  .mul (n) (m) => (NatMax(n)(m)) loop
}

dec InstSemigroupNatMin: Semigroup<Nat>
def InstSemigroupNatMin = begin case {
  .end => !
  .new => (loop) loop
  .mul (n) (m) => (NatMin(n)(m)) loop
}

dec InstSemigroupNatAdd: Semigroup<Nat>
def InstSemigroupNatAdd = begin case {
  .end => !
  .new => (loop) loop
  .mul (n) (m) => (NatAdd(n)(m)) loop
}


// def testSemigroupQueue_pop = let ns = nats in
//   do {ns.next[n1].next[n2].next[n3]} in
//   let q = SemigroupQueue_new(type Nat) in
//   let q = SemigroupQueue_push(type Nat)(instDupNat)(instSemigroupNatMax)(q)(n1) in
//   let q = SemigroupQueue_push(type Nat)(instDupNat)(instSemigroupNatMax)(q)(n2) in
//   let q = SemigroupQueue_push(type Nat)(instDupNat)(instSemigroupNatMax)(q)(n3) in
//
//   let [v]q = SemigroupQueue_peek(type Nat)(instEraNat)(instDupNat)(instSemigroupNatMax)(q) in
//   (v)
//   let [v]q = SemigroupQueue_pop(type Nat)(instEraNat)(instDupNat)(instSemigroupNatMax)(q) in
//   let r = v {
//       none ? => !
//       some v => do { instEraPair(type Nat)(instEraNat).era(v).end?} in !
//     } in
//   do {r?} in
//
//   do {ns.next[n]} in
//   let q = SemigroupQueue_push(type Nat)(instDupNat)(instSemigroupNatMax)(q)(n) in
//
//   let [v]q = SemigroupQueue_pop(type Nat)(instEraNat)(instDupNat)(instSemigroupNatMax)(q) in
//
//   do {ns.end?} in (v) q


// def test_SemigroupStack_reverse =
//   let s = SemigroupStack_new(type Nat) in
//   let s = SemigroupStack_push(type Nat)(instDupNat)(instSemigroupNatMax)(s)(three) in
//   let s = SemigroupStack_push(type Nat)(instDupNat)(instSemigroupNatMax)(s)(two) in
//   let s = SemigroupStack_push(type Nat)(instDupNat)(instSemigroupNatMax)(s)(one) in
//   SemigroupStack_reverse(type Nat)(instEraNat)(instDupNat)(instSemigroupNatMax)(s)
//
// def test_SemigroupStack_reverse2 =
//   let s = SemigroupStack_new(type Nat) in
//   let s = SemigroupStack_push(type Nat)(instDupNat)(instSemigroupNatMax)(s)(one) in
//   let s = SemigroupStack_push(type Nat)(instDupNat)(instSemigroupNatMax)(s)(two) in
//   let s = SemigroupStack_push(type Nat)(instDupNat)(instSemigroupNatMax)(s)(three) in
//   SemigroupStack_reverse(type Nat)(instEraNat)(instDupNat)(instSemigroupNatMax)(s)

// Output a stream of the running measure over a 3 element wide window of nats.
dec SemigroupWin3Nats: [Semigroup<Nat>] Stream<Nat>
def SemigroupWin3Nats = [instSemigroup]
  let ns = Nats in
  do {ns.next[n1].next[n2].next[n3]} in
  let q = SemigroupQueueNew(type Nat) in
  do {instSemigroup.new[instSemigroup2].new[instSemigroup3].new[instSemigroup4]} in
  let q = SemigroupQueuePush(type Nat)(InstDupNat)(instSemigroup2)(q)(n1) in
  let q = SemigroupQueuePush(type Nat)(InstDupNat)(instSemigroup3)(q)(n2) in
  let q = SemigroupQueuePush(type Nat)(InstDupNat)(instSemigroup4)(q)(n3) in
  begin case {
    .end => do {
      instSemigroup.end?
      let ! = InstEraSemigroupQueue(type Nat)(InstEraNat).era(q).end
      ns.end?
    } in !
    .next =>
      do {instSemigroup.new[instSemigroup2]} in
      let (t)q = SemigroupQueuePeek(type Nat)(InstEraNat)(InstDupNat)(instSemigroup2)(q) in
      (t.case {
        .none! => Zero, // unreachable
        .some (t)tm => let ! = InstEraNat.era(t).end in tm
      })
      do {instSemigroup.new[instSemigroup2]} in
      let (v)q = SemigroupQueuePop(type Nat)(InstEraNat)(InstDupNat)(instSemigroup2)(q) in
      v.case {
        .none! => loop // unreachable
        .some (v)vm =>
          do {
            let ! = InstEraNat.era(v).era(vm).end
            instSemigroup.new[instSemigroup2]
            ns.next[n]
          } in
          let q = SemigroupQueuePush(type Nat)(InstDupNat)(instSemigroup2)(q)(n) in
          loop
      }
  }

def TestMaxSemigroupWin3Nats = SemigroupWin3Nats(InstSemigroupNatMax)
def TestMinSemigroupWin3Nats = SemigroupWin3Nats(InstSemigroupNatMin)
def TestAddSemigroupWin3Nats = SemigroupWin3Nats(InstSemigroupNatAdd)
def TestMulSemigroupWin3Nats = SemigroupWin3Nats(InstMulNat)
