type Color = either { .red!, .green!, .blue! }

type Seq<a> = iterative choice {
  .close => !
  .next  => (a) self
}

type Mapper<a, b> = iterative choice {
  .close    => !
  .apply(a) => (b) self
}

dec MapList : [type a, b] [List<a>, Mapper<a, b>] List<b>
def MapList = [type a, b] [list, mapper]
  list.begin.case {
    .empty! => do {
      mapper.close?
    } in .empty!

    .item(x) xs => do {
      mapper.apply(x)[y]
    } in .item(y) xs.loop
  }

dec MapSeq : [type a, b] [Seq<a>, Mapper<a, b>] Seq<b>
def MapSeq = [type a, b] [seq, mapper]
  begin case {
    .close => do {
      seq.close?
      mapper.close?
    } in !
    .next => do {
      seq.next[x]
      mapper.apply(x)[y]
    } in (y) loop
  }

dec ListRGB : List<Color>
def ListRGB =
  .item(.red!)
  .item(.green!)
  .item(.blue!)
  .empty!

dec RedForever : Seq<Color>
def RedForever = begin case {
  .close => !
  .next  => (.red!) loop
}

dec RGB : [Color] Color
def RGB = [value] value.case {
  .red!   => .red!
  .green! => .green!
  .blue!  => .blue!
}

dec Swap : [Bool] Bool
def Swap = [bool] bool.case {
  .true! => .false!
  .false! => .true!
}

dec True  : Bool
dec False : Bool

def True  = chan result { result.true! }
def False = chan result { result.false! }

def BoolsForever =
  let bool: Bool = .true! in
  begin case {
    .close => bool.case {
      .true! => !
      .false! => !
    }
    .next => {
      let (output: Bool, bool: Bool)! = bool.case {
        .true! => (.true!, .false!)!
        .false! => (.false!, .true!)!
      } in (output) loop
    }
  }

dec Zip : [type a, b] [List<a>, Seq<b>] List<(a, b)!>
def Zip = [type a, b] [list, seq] list.begin.case {
  .empty! => do {
    seq.close?
  } in .empty!

  .item(x) xs => do {
    seq.next[y]
  } in .item((x, y)!) xs.loop
}

def Zipped = Zip(type Color, Color)(ListRGB, RedForever)

def Zip2 = [type a, b] [seq1: Seq<a>, seq2: Seq<b>] begin case {
  .close => do {
    seq1.close?
    seq2.close?
  } in !

  .next => do {
    seq1.next[x]
    seq2.next[y]
  } in ((x, y)!) loop
}
