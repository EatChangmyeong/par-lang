type Nat = recursive either {
  .zero!
  .succ self
}

type List<a> = recursive either {
  .empty!
  .item(a) self
}

dec BubbleSort : [List<Nat>] List<Nat>
def BubbleSort = [list] chan yield {
  let yield: chan List<Nat> = list.unfounded.case {
    .empty! => yield,
    .item(first) tail => do {
      let (head, last)! = BubbleSortStep(first, tail)
      let yield = head.loop
      yield.item(last)
    } in yield
  }
  yield.empty!
}

dec BubbleSortStep : [Nat, List<Nat>] (List<Nat>, Nat)!
def BubbleSortStep = [first, tail] tail.begin.case {
  .empty! => (.empty!, first)!
  .item(second) tail => do {
    let (list_first, first)! = Sort2(first, second)
    let (between, last)! = tail.loop
  } in (.item(list_first) between, last)!
}

dec Sort2 : [Nat, Nat] (Nat, Nat)!
def Sort2 = [n1, n2] n1.begin.case {
  .zero! => (.zero!, n2)!
  .succ p1 => n2.case {
    .zero! => (.zero!, .succ p1)!
    .succ p2 => do {
      let n2 = p2
      let (p1, p2)! = p1.loop
    } in (.succ p1, .succ p2)!
  }
}