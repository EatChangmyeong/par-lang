type Tree<a> = recursive either {
  .empty!
  .node(self, a, self)!
}

dec Flatten : [type a] [Tree<a>] List<a>
def Flatten = [type a] [tree] chan yield {
  let yield: dual List<a> = tree.begin.case {
    .empty! => yield,

    .node(left, value, right)! => do {
      let yield = left.loop
      yield.item(value)
    } in right.loop
  }

  yield.end!
}

def Main = Flatten(type Bool)(
  .node(.node(.empty!, .true!, .empty!)!, .false!, .empty!)!
)
