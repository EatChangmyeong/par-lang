def Program: ! = chan exit {
  let console = Console.Open

  catch ! => {
    console.print("Failed to read input.")
    console.close
    exit!
  }

  console.print("Welcome to Mini Grep!")
  console.prompt("Directory: ")[try path]
  console.prompt("Needle: ")[try needle]

  catch e => {
    console.print(e)
    console.close
    exit!
  }

  let try paths: List<Os.Path> = path->Os.Path->TraverseDirectory
  paths.begin.case {
    .end! => {}
    .item(path) => {
      catch e => {
        console.print("")
        console.print(e)
        paths.loop
      }
      let try reader = path->Os.OpenFile
      let lines = GrepFile(needle, reader)
      lines.begin@file.next.case {
        .end try! => {}
        .item((number) content) => {
          console.print("")
          console.print(String.Builder
            .add(path.absolute->String.FromBytes)
            .add(":")
            .add(number->Nat.ToString)
            .build)
          console.print(content)
          lines.loop@file
        }
      }
      paths.loop
    }
  }

  console.close
  exit!
}

dec TraverseDirectory : [Os.Path] Result<Os.Error, List<Os.Path>>
def TraverseDirectory = [dirPath]
  catch e => .err e in
  let try tree = Os.TraverseDir(dirPath) in
  .ok tree.begin.case {
    .end! => .end!,
    .file(path) rest => .item(path) rest.loop,
    .dir(_, nested) rest => Concat(type Os.Path)(nested.loop, rest.loop),
  }

dec GrepFile : [String, Os.Reader] Iterator<Os.Error, (Nat) String>
def GrepFile = [needle, reader]
  String.ParserFromReader(type Os.Error)(reader)
  -> {Lines(type Os.Error)}
  -> {Enumerate1(type Os.Error, String)}
  -> {Filter(type Os.Error, (Nat) String)}(box [(_) line] Contains(needle, line))

// ---

dec Concat : [type a] [List<a>, List<a>] List<a>
def Concat = [type a] [left, right] left.begin.case {
  .end! => right,
  .item(x) xs => .item(x) xs.loop,
}

dec Contains : [String, String] Bool
def Contains = [needle, haystack]
  String.Parser(haystack).match(.repeat.one.any!, .str needle).case {
    .end _ => .false!,
    .fail reader => do {
      reader.close
    } in .false!,
    .match(_, _) reader => do {
      reader.close
    } in .true!,
  }

// ---

type Iterator<e, a> = recursive choice {
  .close => Result<e, !>,
  .next => either {
    .end Result<e, !>,
    .item(a) self,
  }
}

dec Lines : [type e] [String.Parser<e>] Iterator<e, String>
def Lines = [type e] [parser] do { parser.begin } in case {
  .close => parser.close,

  .next => parser.match(.repeat.one.any!, .str "\n").case {
    .end result => .end result,
    .fail parser => parser.remainder.case {
      .err e => .end.err e,
      .ok line => .item(line) case {
        .close => .ok!,
        .next => .end.ok!,
      },
    }
    .match(line, _) parser => .item(line) parser.loop,
  }
}

dec Filter : [type e, a] [Iterator<e, box a>, box [a] Bool] Iterator<e, a>
def Filter = [type e, a] [iter, predicate] do { iter.begin } in case {
  .close => iter.close,
  .next => iter.next.case {
    .end result => .end result,
    .item(value) iter => predicate(value).case {
      .true! => .item(value) iter.loop,
      .false! => iter.begin@skip.next.case {
        .end result => .end result,
        .item(value) iter => predicate(value).case {
          .true! => .item(value) iter.loop,
          .false! => iter.loop@skip,
        }
      },
    }
  }
}

dec Enumerate1 : [type e, a] [Iterator<e, a>] Iterator<e, (Nat) a>
def Enumerate1 = [type e, a] [iter] do {
  let index = 1
  iter.begin
} in case {
  .close => iter.close,
  .next => iter.next.case {
    .end result => .end result,
    .item(value) iter => .item((index) value) do {
      index->Nat.Add(1)
    } in iter.loop
  }
}
