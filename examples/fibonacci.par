type Nat = recursive either {
  .zero!
  .add1 self
}

dec Zero : Nat
dec Add1 : [Nat] Nat
dec Add  : [Nat, Nat] Nat

def Zero = .zero!
def Add1 = [n] .add1 n

def Add = [n1, n2] n1.begin.case {
  .zero!   => n2,
  .add1 n1 => Add1(n1.loop)
}

type Seq<a> = iterative choice {
  .close => !
  .next  => (a) self
}

dec Fibonacci : Seq<Nat>
def Fibonacci =
  let (a) b = (Zero) Add1(Zero)
  in begin case {
    .close => !
    .next =>
      let (a) b = (b) Add(a, b)
      in (a) loop
  }
